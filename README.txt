Dan Ziemba

Required file 'Runfile' is generated by the Makefile.
Code is also available at https://github.com/zman0900/cse755-lisp
Javadoc is available by running `make doc`


Design Information:

I used the LL(1) grammar from the project description with whitespace removed
since my lexer handles ensuring required whitespace is where it belongs.

LL(1) Grammar with numbered rules:
1.	<S> ::= <E>
2.	<E> ::= atom
3.	      | (<X>
4.	<X> ::= )
5.	      | <E><Y>
6.	<Y> ::= .<E>)
7.	      | <R>)
8.	<R> ::= <E><R>
9.	      | empty

I constructed an LL(1) parse table based on the info from wikipedia's LL parser
page: http://en.wikipedia.org/wiki/LL_parser

First-sets:
E - { atom, ( }
R - { empty, atom, ( }
S - { atom, ( }
X - { ), atom, ( }
Y - { ), atom, (, . }

Follow-sets:
E - { ), $, atom, (, . }
R - { c }
S - { $ }
X - { ), $, atom, (, . }
Y - { ), $, atom, (, . }

Parse table:
 |  .| atom|  )|  (|  $
_|___|_____|___|___|____
E|   |    2|   |  3|
R|   |    8|  9|  8|
S|   |    1|   |  1|
X|   |    5|  4|  5|
Y|  6|    7|  7|  7|


As the parser matches terminal symbols, it constructs an s-expression that is 
stored in a binary tree format.  These s-expressions are then read by the 
interpreter class and executed in a very similar manner to what was described in
class for the lisp interpreter implemented in lisp, although this interpreter
also performs error checking.