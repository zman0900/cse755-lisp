Dan Ziemba

Required file 'Runfile' is generated by the Makefile.
Code is also available at https://github.com/zman0900/cse755-lisp
Javadoc is available by running `make doc`
Run program with -d flag to enable debug output.


Design Information:

This interpreter is designed to use a parser, which uses a tokenizer, which uses
a slightly modified version of Java's StreamTokenizer, to read Lisp programs
from standard input and display the results to standard output.

The tokenizer uses the IntStreamTokeinzer class to do most of the work.  
IntStreamTokenizer is nearly identical to Java's StreamTokenizer except it has
been modified to only accept integers as numbers.  Due to its design I couldn't
achieve this by subclassing it, so I just copied the source code.

To design the parser, I used the LL(1) grammar from the project description with
whitespace removed since my tokenizer handles ensuring required whitespace is 
where it belongs.

LL(1) Grammar with numbered rules:
1.	<S> ::= <E>
2.	<E> ::= atom
3.	      | (<X>
4.	<X> ::= )
5.	      | <E><Y>
6.	<Y> ::= .<E>)
7.	      | <R>)
8.	<R> ::= <E><R>
9.	      | empty

I constructed an LL(1) parse table based on the info from wikipedia's LL parser
page: http://en.wikipedia.org/wiki/LL_parser

First-sets:
E - { atom, ( }
R - { empty, atom, ( }
S - { atom, ( }
X - { ), atom, ( }
Y - { ), atom, (, . }

Follow-sets:
E - { ), $, atom, (, . }
R - { c }
S - { $ }
X - { ), $, atom, (, . }
Y - { ), $, atom, (, . }

Parse table:
 |  .| atom|  )|  (|  $
_|___|_____|___|___|____
E|   |    2|   |  3|
R|   |    8|  9|  8|
S|   |    1|   |  1|
X|   |    5|  4|  5|
Y|  6|    7|  7|  7|

The parser operates by reading tokens in series from the tokenizer.  It has a 
stack that starts out with the starting non-terminal symbol S on top.  It also
has a map that maps a non-terminal and terminal symbol to a rule number.  For 
each new token the parser gets, it converts it to a terminal-symbol, then 
compares that symbol with the top of the stack.  If the symbols match, they are 
removed and the process is repeated with the next token.  If the symbol on the 
stack is a terminal symbol that doesn't match, then the input is invalid. 
Otherwise, the symbol is non-terminal, and it is used along with the symbol from
the token to look up a rule number.  If one is not found, the input is invalid. 
The rule is applied by removing the top of the stack, then pushing the symbols 
from the right side of the rule onto the stack in reverse. The process is then 
repeated with the same token. 

As the parser matches terminal symbols, it constructs an s-expression that is 
stored in a binary tree format.  These s-expressions are then read by the 
interpreter class and executed in a very similar manner to what was described in
class for the lisp interpreter implemented in lisp, although this interpreter
also performs error checking.